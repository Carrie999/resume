{"ast":null,"code":"'use strict';\n\n(function () {\n  var ls = typeof window !== 'undefined' ? window.localStorage : null,\n      ms = require('ms'),\n      lzstring = require('lz-string'); // Provide an in-memory fallback for\n  // older browsers.\n\n\n  if (!ls) {\n    ls = {\n      _data: {},\n      setItem: function setItem(id, val) {\n        return this._data[id] = String(val);\n      },\n      getItem: function getItem(id) {\n        return this._data.hasOwnProperty(id) ? this._data[id] : undefined;\n      },\n      removeItem: function removeItem(id) {\n        return delete this._data[id];\n      },\n      key: function key(index) {\n        for (var key in this_data) {\n          if (!index--) {\n            return key;\n          }\n        }\n      },\n      clear: function clear() {\n        return this._data = {};\n      }\n    };\n  } // Fastest utility functions for this case.\n  // Faster than underscore and lodash.\n  // Besides, do I even need them here?\n\n\n  var utils = {\n    each: function each(arr, iteratee) {\n      var l = arr.length;\n\n      while (l--) {\n        iteratee(arr[l], l);\n      }\n    },\n    map: function map(arr, iteratee) {\n      var newArr = new Array(arr.length),\n          l = arr.length;\n\n      while (l--) {\n        newArr[l] = iteratee(arr[l], l);\n      }\n\n      return newArr;\n    },\n    filter: function filter(arr, iteratee) {\n      var newArr = [],\n          l = arr.length;\n\n      while (l--) {\n        if (iteratee(arr[l], l)) newArr.push(arr[l]);\n      }\n\n      return newArr;\n    }\n  };\n\n  var _keys,\n      _config,\n      _compressAll,\n      _timeouts = {};\n\n  var Locally = function Locally(options) {\n    // custom options\n    options = options || {};\n    _compressAll = options.compress; // load current localStorage state\n\n    _config = ls.getItem('locally-config'); // start anew if no config\n\n    if (!_config) {\n      _config = {}; // reads localstorage and updates config\n\n      _rebuildConfig();\n    } else {\n      var deconfig = lzstring.decompressFromUTF16(_config);\n\n      try {\n        _config = JSON.parse(deconfig || _config);\n      } catch (e) {\n        if (!!deconfig) {\n          try {\n            _config = JSON.parse(_config);\n          } catch (e) {\n            throw new Error('Locally: config is corrupted');\n          }\n        } else throw new Error('Locally: config is corrupted');\n      } // reads localstorage and updates config\n\n\n      _rebuildConfig();\n    }\n\n    _saveConfig();\n\n    Object.defineProperty(this, 'length', {\n      get: function get() {\n        return _keys.length;\n      }\n    });\n  };\n\n  Locally.prototype.set = function (key, value, options) {\n    if (arguments.length < 2) throw new Error('Locally: no key or value given');\n    options = options || {};\n\n    if (typeof options !== 'object') {\n      options = {\n        ttl: options\n      };\n    }\n\n    if (typeof options.ttl === 'string') {\n      options.ttl = ms(options.ttl);\n    } // Set TTL\n\n\n    _config[key] = _config[key] || {}; // Add to keys array\n\n    if (_keys.indexOf(key) == -1) {\n      _keys.push(key);\n    } // Set TTL\n\n\n    if (options.ttl && !isNaN(options.ttl)) {\n      _clearTimeout(key);\n\n      _setTimeout(key, options.ttl);\n    } else if (_config[key].ttl) {\n      _clearTimeout(key);\n    } // LocalStorage saves and returns values as strings.\n    // Type of values will be saved so that values will be\n    // parsed to their original type.\n\n\n    var res = _getType(value);\n\n    value = res.value;\n    _config[key].t = res.type; // compression\n\n    if (options.compress || _compressAll) {\n      _config[key].c = 1;\n      value = lzstring.compressToUTF16(value.toString());\n    }\n\n    key = String(key);\n    value = String(value);\n    ls.setItem(key, value);\n\n    _saveConfig();\n  };\n\n  Locally.prototype.get = function (key) {\n    return Array.isArray(key) ? utils.map(key, function (item) {\n      return _get(item);\n    }.bind(this)) : _get(key);\n  };\n\n  Locally.prototype.keys = function (pattern) {\n    // Return all keys\n    if (!pattern || pattern == '*') return _keys.slice(0); // RegExp pattern to be queried\n\n    if (!(pattern instanceof RegExp)) {\n      pattern = new RegExp('.*' + pattern + '.*');\n    }\n\n    return utils.filter(_keys, function (key) {\n      return pattern.test(key);\n    });\n  };\n\n  Locally.prototype.remove = function (key) {\n    if (typeof key === 'undefined') throw new Error('Locally: \\'remove\\' requires a key');\n\n    if (Array.isArray(key)) {\n      utils.each(key, _remove);\n    } else {\n      _remove(key);\n    }\n  }; // callback gets 'value' and 'key' as parameters\n\n\n  Locally.prototype.scan = function (key, fn) {\n    return utils.each(this.keys(key), function (key) {\n      fn(_get(key), key);\n    });\n  };\n\n  Locally.prototype.ttl = function (key, returnString) {\n    return _config[key] ? _config[key].ttl ? !returnString ? _config[key].ttl - Date.now() : ms(_config[key].ttl - Date.now()) : -1 : -2;\n  };\n\n  Locally.prototype.persist = function (key) {\n    return _config[key] ? delete _config[key].ttl && _saveConfig() && _clearTimeout(key) : false;\n  };\n\n  Locally.prototype.expire = function (key, ttl) {\n    return _config[key] ? !!(_config[key].ttl = Date.now() + ttl) && _saveConfig() : false;\n  };\n\n  Locally.prototype.clear = function () {\n    ls.clear();\n    _config = {};\n    _keys = [];\n    return _saveConfig();\n  };\n\n  Locally.prototype.key = function (index) {\n    return _keys[index];\n  }; // Removes a value from localStorage\n\n\n  function _remove(key) {\n    var i = _keys.indexOf(key);\n\n    if (i > -1) {\n      ls.removeItem(key);\n\n      _keys.splice(_keys.indexOf(key), 1);\n\n      delete _config[key];\n    }\n  } // Saves config to localStorage\n\n\n  function _saveConfig() {\n    ls.setItem('locally-config', lzstring.compressToUTF16(JSON.stringify(_config)));\n    return true;\n  }\n\n  function _get(key) {\n    // Return null if no key is given\n    if (typeof key === 'undefined' || !_config[key]) return null; // Check for TTL\n    // If TTL is exceeded delete data\n    // and return null\n\n    if (_config[key].ttl && _config[key].ttl < Date.now()) {\n      delete _config[key];\n\n      _saveConfig();\n\n      _remove(key);\n\n      return null;\n    }\n\n    var temp,\n        value = _config[key].c ? lzstring.decompressFromUTF16(ls.getItem(key)) : ls.getItem(key); // Return value in correct type\n\n    switch (_config[key].t) {\n      case 'o':\n        try {\n          value = JSON.parse(value);\n        } catch (e) {}\n\n        return value;\n        break;\n\n      case 'd':\n        return new Date(parseInt(value, 10));\n        break;\n\n      case 'r':\n        return new RegExp(value.substring(1, value.length - 1));\n        break;\n\n      case 'f':\n        eval('temp = ' + value);\n        return temp;\n        break;\n\n      case 'n':\n        return Number(value);\n        break;\n\n      case 'b':\n        return value == '1';\n        break;\n\n      case 's':\n      default:\n        if (value === 'null') return null;else if (value === 'undefined') return undefined;else return String(value);\n        break;\n    }\n  }\n\n  function _getType(value) {\n    var type;\n\n    switch (typeof value) {\n      case 'object':\n        // Keep Date objects as timestamps\n        if (value instanceof Date) {\n          value = value.getTime();\n          type = 'd';\n        } // Keep RegExp objects as strings\n        else if (value instanceof RegExp) {\n            value = value.toString();\n            type = 'r';\n          } // Otherwise keep them as JSON\n          else {\n              value = JSON.stringify(value);\n              type = 'o';\n            }\n\n        break;\n\n      case 'function':\n        type = 'f';\n        break;\n\n      case 'number':\n        type = 'n';\n        break;\n\n      case 'boolean':\n        value = value ? 1 : 0;\n        type = 'b';\n        break;\n\n      case 'string':\n      default:\n        type = 's';\n    }\n\n    return {\n      value: value,\n      type: type\n    };\n  }\n\n  function _rebuildConfig() {\n    var l = ls.length;\n    _keys = new Array(l); // Cache localStorage keys for faster access\n\n    while (l--) {\n      _keys[l] = ls.key(l);\n      _config[_keys[l]] = _config[_keys[l]] || {}; // _compressAll is given and value is not\n      // compressed then compress the value\n\n      if (_compressAll && !_config[_keys[l]].c) {\n        _config[_keys[l]].c = true;\n        ls.setItem(_keys[l], lzstring.compressToUTF16(ls.getItem(_keys[l])));\n      } // if the value is compressed and\n      // compressAll is not given then decompress\n      // current value.\n      else if (!_compressAll && _config[_keys[l]].c) {\n          delete _config[_keys[l]].c;\n          ls.setItem(_keys[l], lzstring.decompressFromUTF16(ls.getItem(_keys[l])));\n        }\n\n      if (_config[_keys[l]].ttl) {\n        _setTimeout(_keys[l], _config[_keys[l]].ttl - Date.now());\n      }\n    } // Exclude locally-config from _keys array\n\n\n    if (_keys.indexOf('locally-config') > -1) {\n      _keys.splice(_keys.indexOf('locally-config'), 1);\n    }\n  }\n\n  function _setTimeout(key, ttl) {\n    _config[key].ttl = Date.now() + ttl;\n    _timeouts[key] = setTimeout(function () {\n      _remove(key);\n    }, ttl);\n  }\n\n  function _clearTimeout(key) {\n    if (_keys.indexOf(key) > -1) {\n      clearTimeout(_timeouts[key]);\n      delete _timeouts[key];\n      delete _config[key].ttl;\n      return true;\n    } else return false;\n  } // CommonJS\n\n\n  if (typeof exports === 'object') {\n    module.exports.Store = Locally;\n  } // AMD. Register as an anonymous module.\n\n\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return {\n        Store: Locally\n      };\n    });\n  } // Browser global.\n\n\n  if (typeof window === 'object') {\n    window.Locally = {\n      Store: Locally\n    };\n  }\n})();","map":null,"metadata":{},"sourceType":"script"}